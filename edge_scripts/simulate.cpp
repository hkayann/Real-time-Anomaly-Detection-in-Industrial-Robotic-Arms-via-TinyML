/**
 * Nicla Sense Specs:
 * 512KB Flash / 64KB RAM,
 * 2MB SPI Flash for storage,
 * 2MB QSPI dedicated for BHI260AP.
*/

#include <math.h>
#include "model.h"
#include "tensorflow/lite/micro/micro_interpreter.h"
#include "tensorflow/lite/micro/micro_mutable_op_resolver.h"
#include "tensorflow/lite/micro/system_setup.h"
#include "tensorflow/lite/schema/schema_generated.h"
#include "tensorflow/lite/core/c/common.h"
#include "tensorflow/lite/micro/micro_log.h"
#include "Arduino_BHY2.h"
// #include "ArduinoBLE.h"
// #include "Nicla_System.h"

/**
 * Important that the Arduino include comes last if on the Arduino platform, as it has an `abs()` function
 * that will screw with the stdlib abs() function. If need you can use the following lines
 * as well to redeclare the abs() function to be compatible
*/
#include "Arduino.h"
#ifdef ARDUINO
#define abs(x) ((x)>0?(x):-(x))
#endif 

//----------------------------------------------------------------------------------------------------------------------
// Uncomment to check min-max values used to normalize the data.
//----------------------------------------------------------------------------------------------------------------------

// void printNormalizationConstants() {
//     Serial.println("Normalization Constants:");
//     Serial.print("ACCX_MIN: "); Serial.println(ACCX_MIN, 4);
//     Serial.print("ACCX_MAX: "); Serial.println(ACCX_MAX, 4);
//     Serial.print("ACCY_MIN: "); Serial.println(ACCY_MIN, 4); 
//     Serial.print("ACCY_MAX: "); Serial.println(ACCY_MAX, 4);
//     Serial.print("ACCZ_MIN: "); Serial.println(ACCZ_MIN, 4); 
//     Serial.print("ACCZ_MAX: "); Serial.println(ACCZ_MAX, 4);
//     Serial.print("GYROX_MIN: "); Serial.println(GYROX_MIN, 4); 
//     Serial.print("GYROX_MAX: "); Serial.println(GYROX_MAX, 4);
//     Serial.print("GYROY_MIN: "); Serial.println(GYROY_MIN, 4);
//     Serial.print("GYROY_MAX: "); Serial.println(GYROY_MAX, 4);
//     Serial.print("GYROZ_MIN: "); Serial.println(GYROZ_MIN, 4); 
//     Serial.print("GYROZ_MAX: "); Serial.println(GYROZ_MAX, 4);
//     Serial.print("MAGX_MIN: "); Serial.println(MAGX_MIN, 4); 
//     Serial.print("MAGX_MAX: "); Serial.println(MAGX_MAX, 4);
//     Serial.print("MAGY_MIN: "); Serial.println(MAGY_MIN, 4); 
//     Serial.print("MAGY_MAX: "); Serial.println(MAGY_MAX, 4);
//     Serial.print("MAGZ_MIN: "); Serial.println(MAGZ_MIN, 4); 
//     Serial.print("MAGZ_MAX: "); Serial.println(MAGZ_MAX, 4);
// }

//----------------------------------------------------------------------------------------------------------------------
// TFLite Micro Operations
//----------------------------------------------------------------------------------------------------------------------

// Globals, used for compatibility with Arduino-style sketches.
namespace {
const tflite::Model* model = nullptr;
tflite::MicroInterpreter* interpreter = nullptr;
TfLiteTensor* input = nullptr;
TfLiteTensor* output = nullptr;

// Arena size just a round number. The exact arena usage can be determined
// using the RecordingMicroInterpreter.
constexpr int kTensorArenaSize = 18000; // in bytes;
// Keep aligned to 16 bytes for CMSIS
alignas(16) uint8_t tensor_arena[kTensorArenaSize];
}  // namespace

// Create required variables
const int numRows = 45;
const int numFloatsPerRow = 9;
float floatValues[numRows * numFloatsPerRow]; // Array to store floats generated by sensors
float predictedValues[numFloatsPerRow]; // Array to hold predictions per inference.
float totalRMSE = 0.0; // Array to store floats predicted by ML model

void setup()
{

    // Assign the initial value of variables
    floatValues[0] = 0.0;
    predictedValues[0] = 0.0;
    Serial.begin(115200);

    // Block until BHY2 sensor is initialized
    // while(!BHY2.begin(NICLA_STANDALONE)) {;}
    // Block until BLE module is initialized
    // while(!BLE.begin()) {;}
    tflite::InitializeTarget();
    // Map the model into a usable data structure. This doesn't involve any
    // copying or parsing, it's a very lightweight operation.
    model = tflite::GetModel(g_model);

    // This pulls in all the operation implementations we need.
    // 4 for LSTM 5 for CNN
    static tflite::MicroMutableOpResolver<5> resolver;

    // Operation for CNN
    // resolver.AddConv2D();
    // resolver.AddMaxPool2D();
    // resolver.AddRelu();
    // resolver.AddReshape();
    // resolver.AddFullyConnected();

    // Needed for LSTM
      resolver.AddUnidirectionalSequenceLSTM();
      resolver.AddReshape();
      resolver.AddStridedSlice();
      resolver.AddFullyConnected();

    // Build an interpreter to run the model with
    static tflite::MicroInterpreter static_interpreter(
        model, resolver, tensor_arena, kTensorArenaSize);
    interpreter = &static_interpreter;

    // Allocate memory from the tensor_arena for the model's tensors.
    TfLiteStatus allocate_status = interpreter->AllocateTensors();
    if (allocate_status != kTfLiteOk)
    {
        return;
    }
    else
    {
        size_t used_bytes = interpreter->arena_used_bytes();
        Serial.print("Tensor arena used bytes: ");
        Serial.println(used_bytes);
    }

    // Print out the input tensor's details to verify
    // the model is working as expected
    // Obtain pointers to the model's input and output tensors.
    input = interpreter->input(0);
    output = interpreter->output(0);
}

int floatCount = 0; // Counter for received floats
unsigned long lastReceiveTime = millis();
float output_data[9];

void loop() {

  if (Serial.available() >= 4) {
    // Read a float and store it in the array
    if (floatCount < numRows * numFloatsPerRow) { // 45 * 9
      
      float incomingFloat;
      Serial.readBytes((char*)&incomingFloat, sizeof(float));
      
      // Determine which sensor the current float belongs to based on floatCount
      int sensorIndex = floatCount % numFloatsPerRow;
      
      // Standardize the incomingFloat based on sensorIndex
      switch(sensorIndex) {
          case 0: // ACCX
              incomingFloat = (incomingFloat - ACCX_MEAN) / ACCX_STD;
              break;
          case 1: // ACCY
              incomingFloat = (incomingFloat - ACCY_MEAN) / ACCY_STD;
              break;
          case 2: // ACCZ
              incomingFloat = (incomingFloat - ACCZ_MEAN) / ACCZ_STD;
              break;
          case 3: // GYROX
              incomingFloat = (incomingFloat - GYROX_MEAN) / GYROX_STD;
              break;
          case 4: // GYROY
              incomingFloat = (incomingFloat - GYROY_MEAN) / GYROY_STD;
              break;
          case 5: // GYROZ
              incomingFloat = (incomingFloat - GYROZ_MEAN) / GYROZ_STD;
              break;
          case 6: // MAGX
              incomingFloat = (incomingFloat - MAGX_MEAN) / MAGX_STD;
              break;
          case 7: // MAGY
              incomingFloat = (incomingFloat - MAGY_MEAN) / MAGY_STD;
              break;
          case 8: // MAGZ
              incomingFloat = (incomingFloat - MAGZ_MEAN) / MAGZ_STD;
              break;
      }
      // Store the standardized float
      floatValues[floatCount] = incomingFloat;
      floatCount++;

      // Check if a whole row has been received, including for the last row
      if (floatCount % numFloatsPerRow == 0 || floatCount == numRows * numFloatsPerRow) {
        delay(10); // Short delay before sending ACK
        Serial.write("ACK", 3); // Send ACK
        Serial.flush(); // Ensure ACK is sent before proceeding
      }
    }
  }

  // After receiving all floats for n rows, perform inference and echo back the output
  if (floatCount == numRows * numFloatsPerRow) {
  
    // Populate the input tensor with received data
    for (int i = 0; i < input->bytes / sizeof(float); i++) {
      input->data.f[i] = floatValues[i];
    }

    // Run inference
    TfLiteStatus invoke_status = interpreter->Invoke();
    if (invoke_status != kTfLiteOk) {
      Serial.println("Invoke failed!");
    } else {
      // Copy the model's output into output_data
      for (int i = 0; i < 9; i++) {
        output_data[i] = output->data.f[i];
      }

      // Reverse standardize the output_data based on sensorIndex
      for (int i = 0; i < 9; i++) {
        switch(i) {
            case 0: // ACCX
                output_data[i] = (output_data[i] * ACCX_STD) + ACCX_MEAN;
                break;
            case 1: // ACCY
                output_data[i] = (output_data[i] * ACCY_STD) + ACCY_MEAN;
                break;
            case 2: // ACCZ
                output_data[i] = (output_data[i] * ACCZ_STD) + ACCZ_MEAN;
                break;
            case 3: // GYROX
                output_data[i] = (output_data[i] * GYROX_STD) + GYROX_MEAN;
                break;
            case 4: // GYROY
                output_data[i] = (output_data[i] * GYROY_STD) + GYROY_MEAN;
                break;
            case 5: // GYROZ
                output_data[i] = (output_data[i] * GYROZ_STD) + GYROZ_MEAN;
                break;
            case 6: // MAGX
                output_data[i] = (output_data[i] * MAGX_STD) + MAGX_MEAN;
                break;
            case 7: // MAGY
                output_data[i] = (output_data[i] * MAGY_STD) + MAGY_MEAN;
                break;
            case 8: // MAGZ
                output_data[i] = (output_data[i] * MAGZ_STD) + MAGZ_MEAN;
                break;
        }
      }

      // Echo back the model's scaled output
      for (int i = 0; i < 9; i++) {
        Serial.write((const unsigned char*)&output_data[i], sizeof(float));
        Serial.flush();
      }
    }
    floatCount = 0; // Reset the counter for the next set of rows
  }
}